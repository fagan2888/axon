import pandas as pd

from avg_fun import kde_wavg


def agg_itineraries(points_merged, CONFIG):

    # TODO is this still needed the escape below
    if points_merged.empty:
        return None

    grouped = points_merged.groupby(['mot_segment_id', 'itinerary_id'])

    diagnostics = grouped.agg({
        'distance': {
            'mean': lambda x: x.mean(),
            'count': lambda x: x.count(),
            'median': lambda x: x.median(),
            'min': lambda x: x.min(),
            'max': lambda x: x.max(),
            # 'filtered_mean': lambda x: x[outlier_flag(x)].mean()
            # 'sem': lambda x: x.std() / np.sqrt(x.count().astype(float))
            #  Standard error on the mean -- big bias because of the non-gaussisanity of the underlying distribution...
            #  also remove NaN
            #  Need the in_mot_segment boolean to implement below...
        },
        'within_mot_segment': {
            'n_time_in': lambda x: x.astype(int).sum()
        }})

    # Count the total number of points in MoT segment, join for all itineraries
    pts_within_mot = points_merged.loc[points_merged['within_mot_segment'], ['mot_segment_id', 'point_id']]
    pts_within_mot_count = pts_within_mot.drop_duplicates().groupby(['mot_segment_id']).count()
    cnt = diagnostics.join(pts_within_mot_count)['point_id'].astype(float)

    # Removes the top-most hierarchical index generated by the aggregation query (distance)
    diagnostics.columns = diagnostics.columns.droplevel(0)

    # This needs a full apply since more than one column is involved
    long_stop_weight = float(CONFIG.get('params', 'TRAIN_LONG_STOP_WEIGHT'))
    diagnostics['kde_weighed_avg'] = grouped.apply(kde_wavg, wgt=long_stop_weight)

    # Changes dtypes
    col_list = ['min', 'max', 'median', 'mean', 'kde_weighed_avg']
    diagnostics[col_list] = diagnostics[col_list].astype(int)
    # Sometimes is boolean if all 1
    diagnostics['n_time_in'] = diagnostics['n_time_in'].astype(float) / cnt

    diagnostics['warning_str'] = diagnostics.apply(raise_flags, axis=1, args=(CONFIG,))
    diagnostics['warning_bool'] = diagnostics['warning_str'] != ''

    # Sorts on boolean is false first (no warning) then distance kde weighted
    return diagnostics.reset_index().sort_values(['mot_segment_id', 'warning_bool', 'kde_weighed_avg'])


def compare_itineraries(group):
    """ Generate statistics from the diagnostics/metrics
    requires a series, e.g. x = diagnostics['kde_weighed_avg']

    !! GROUP MUST BE SORTED IN ASCENDING ORDER !!
    """

    col_names = ['itinerary_id', 'count', 'n_time_in', 'warning_bool', 'warning_str', 'min_value', 'delta_next', 'n2x',
                 'confidence']
    stats = pd.Series(index=col_names)
    stats[col_names[:5]] = group[col_names[:5]].iloc[0]  # x.argmin()

    x = group['kde_weighed_avg']
    stats['min_value'] = x.iloc[0]  # x.min()

    if x.shape[0] > 1:
        stats['delta_next'] = x.nsmallest(2).iloc[1] - x.nsmallest(2).iloc[0]
        stats['n2x'] = x[x < x.min()*2.].count() - 1
    else:
        stats['delta_next'] = -1
        stats['n2x'] = -1

    # Confidence =0 if flag is raised, =1 if no flag and kde_weighed_avg=0, reduces by 1/2 if other itineraries nearby
    # TODO : check it works, also add * n_pts_in ?
    stats['confidence'] = (1. - group['warning_bool'].iloc[0].astype(int)) * (1. - stats['min_value']/7000.)\
        * 0.5 * (2 - (int((stats['delta_next'] < 1500) and (stats['delta_next'] >= 0)))) * stats['n_time_in']
    return stats


def raise_flags(diagnostic, CONFIG):
    """
    diagnostic is one row of diagnostics

    :param diagnostic: pandas.Series (single row of diagnostics DataFrame)
    :param CONFIG:
    :return: str, each warning separated by \n
    """

    n_row_min = int(CONFIG.get('params', 'N_ROW_MIN'))
    n_dist_max = int(CONFIG.get('params', 'N_DIST_MAX'))
    n_time_min = float(CONFIG.get('params', 'N_TIME_MIN'))

    warning_list = ['']
    if diagnostic['count'] < n_row_min:
        warning_list.append('WARNING -- Low Counts (<{x})'.format(x=n_row_min))
    if diagnostic['kde_weighed_avg'] > n_dist_max:
        warning_list.append('WARNING -- High Avg. Distance (>{x}k)'.format(x=int(n_dist_max/1000)))
    if diagnostic['n_time_in'] < n_time_min:
        warning_list.append('WARNING -- Low overlap with MoT segment (<{x})'.format(x=n_time_min))

    return '\n'.join(warning_list)


def get_best_itinerary(trip_link, points, point_meta, CONFIG):

    # Merge all 3 dataframe together, excluding out of order outlier points (ooo_outlier)
    points_merged = pd.merge(trip_link.reset_index()[['mot_segment_id', 'itinerary_id', 'leg_id', 'segment_id']],
                             point_meta[~point_meta['ooo_outlier']].reset_index(), on='segment_id', how='inner')
    points_merged = pd.merge(points_merged, points.reset_index(), on='point_id', how='inner')

    # Generate quality metrics for each itinerary (returns sorted by 'quality')
    diagnostics = agg_itineraries(points_merged, CONFIG)

    # Compares the best itinerary to the others and surfaces stats
    stats = diagnostics.groupby('mot_segment_id').apply(compare_itineraries)

    return stats, diagnostics
